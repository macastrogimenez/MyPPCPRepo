The Java Memory Model (for PCPP)
by Ra´ ul Pardo (raup@itu.dk) — version 2025-9-8.
This chapter summarizes the Java memory model and adapts it to the purposes of the PCPP course.
The changes simply omit details on how the Java memory model must be enforced by implementations
of the Java Virtual Machine. The definitions and reasoning described in this note are a consistent
subset of the complete Java memory model1[2]. Therefore, the concepts and reasoning discussed here
are applicable to analyze real Java software.
The Java memory model defines, given a concurrent Java program, the set of valid executions of
the program. The Java Just-In-Time (JIT) compiler and Java Virtual Machine (JVM) guarantee that
concurrent Java programs only produce executions allowed by the Java memory model. This guarantee
is enforced in all hardware and operating systems supported by the Java runtime environment.
Precisely defining what are the possible executions of a program gives programmers the ability to
predict the behavior of their programs. For instance, one of the main goals of the memory model is to
determine, given an execution, what values are observed when performing a read on a variable.
Memory models in other programming languages We remark that a memory model is not a
Java specific concept. Many popular programming languages have memory models, e.g., C/C++,2C#3
or Go4just to mention a few. Generally, programming languages used for concurrent programming
strive to precisely define a memory model, as it allows programmers to predict the behavior of their
programs and ensure their correctness. For instance, the developers of the (rather new) programming
language Rust are making efforts to define its memory model.5This is because, when a programming
language with support for concurrency does not have a memory model, programmers cannot easily
predict the behavior of their programs. The memory model for Java was the first to be completely
formalized [2]. As a consequence, it is one of the most complete and mature memory models out there.
1 Why do we need a memory model?
As mentioned above, a memory model allows programmers to predict the behavior of their concurrent
programs. When no synchronization primitives are used in concurrent programs, they typically exhibit
behavior that is considered paradoxical by programmers.
Example 1.Consider the program below—which we discussed in lecture 2.
Due to the lack of synchronization, the value of ( x,y) after the execution of the program can
be (1,1), (0,1), (1,0), but also (0,0). Most programmers would consider the first three cases as
expected behaviors (due to the program interleavings). The result (1,1) can be generated by in-
terleavings (1),(3),(2),(4) or(1),(3),(4),(2) or(3),(1),(2),(4) or(3),(1),(4),(2) . The
result (0,1) and (1,0) by interleavings (1),(2),(3),(4) or(3),(4),(1),(2) , respectively. However,
the result (0,0) would be unexpected for most programmers. The reason is that only interleavings
(2),(4),(1),(3) or(2),(4),(2),(4) or(4),(2),(1),(3) or(4),(2),(2),(4) can produce that
result. Note that these interleavings seem to contradict intra-thread order. That is, operation (2)
occurs before (1)in thread one, and operation (4)occurs before operation (3). This is considered
unexpected or paradoxical by many programmers.
1Java Language Specification — Chapter 17. Threads and Locks (Java Memory Model).
2C++ memory model.
3C# memory model.
4Go memory model.
5Rust memory model (incomplete).
1

Listing 1: Example of concurrent program with unexpected behavior.
// Initial values
int x=0;y=0;
int a=0;b=0;
// Threads definition
Thread one = new Thread (() -> {
a=1; // (1)
x=b; // (2)
}). start ();
Thread other = new Thread (() -> {
b=1; // (3)
y=a; // (4)
}). start ();
The unexpected program executions illustrated in example 1 occur due to compiler and hardware
optimizations built-in the JIT compiler, the JVM or the computer’s CPU. Without these optimizations,
running concurrent programs would not be as efficient as it is today.
2 Sequential consistency
What we have called “expected behavior” in the previous section is known as sequential consistency .
The notion of sequential consistency was first introduced by Leslie Lamport in the late 70s [1]. In a
nutshell, a concurrent execution is sequentially consistent iff i) it preserves program order (i.e., intra-
thread consistency); and ii) operations appear to occur one at a time. For now, this intuition is all you
need to know about sequential consistency. In the coming weeks, we will cover sequential consistency
in detail. The mandatory readings for sequential consistency include Leslie Lamport’s paper [1] and
Section 3.3 in Herlihy.
Note that, if a runtime environment—such as the JVM—would enforce sequential consistency, then
the interleavings producing (0,0) in example 1 would not be allowed. However, ensuring sequential
consistency for all concurrent programs would require disabling compilation and CPU optimizations
that increase performance .
As we will see below, the Java memory model allows programmers to use synchronization operations
to control the behavior of their concurrent programs without the need to globally disable compilation
or CPU optimizations.
3 Basic definitions
In this section, we provide the definitions of Java memory model that we will use in the course as well
as examples on how to use them to reason about concurrent Java programs.
As mentioned earlier, the content in this section corresponds to a subset of the definitions in the
complete Java memory model. This subset contains the required definitions to establish correctness of
Java concurrent programs according to the Java memory model (cf. section 4), and omits details on
how the Java memory model is enforced by the Java virtual machine.
3.1 Actions
LetOdenote a set of operations andTa set of threads . Given a thread t∈ Tand an operation o∈ O,
andaction , denoted as t(o), represents the execution of operation oby thread t. We use A ⊆ T × O
2

to denote the set of all actions.
We consider three types of actions:
Variable accesses These actions correspond to read and write accesses on program variables. For
instance, x=1is a write access on variable xand, when evaluating the program term x>0, a read
access on variable xis executed.
Synchronization actions These actions correspond to synchronization primitives, which includes:
–lock() /unlock() method calls on locks. Recall that other synchronization primitives such
as monitors or semaphores internally use locks in their implementation.
–Write/read accesses on volatile variables.
–Operations that start a thread (such as start() ) or detect that a thread has terminated
(such as join() ).
Other actions This category of actions corresponds to any actions not included in the other two
categories. Actions in this category are often uninteresting for concurrency purposes.
Generally, an operation orefers to a program statement. However, actions executing an operation
may have multiple categorizations. For example, in listing 1, the operation (2)corresponds to program
statement x=b. When a thread executes this operation, the action classifies as a read access on variable
band a write access to variable x. For operations on method calls, sometimes we might abstract from
the implementation of the method and simply assume whether it performs a read or write access on a
variable. For instance, given an object sof type Set, the action modeling the execution of s.add(x)
can be categorized as a write access on sand a read access on x. If you use this type of abstractions
in your reasoning, you must explicitly mention it.
3.2 Executions
Anexecution e∈ Eis a sequence of actions e=a1, a2, . . .where ai∈ A. We use a∈eto denote that
action aoccurs in execution e. The execution specifies the order in which actions are executed by the
concurrent program. Recall that a single concurrent program may lead to multiple possible executions.
Note also that this definition of execution is the same as the one for interleavings (introduced in lecture
1). In fact, the syntax for executions is similar to that of interleavings.
Example 2.Note that in the interleavings in example 1, we have omitted the thread identifier due to the
lack of ambiguity. Consider the execution that results in x==0 andy==1 and let t1, t2 denote threads one
andother , respectively. To precisely follow the syntax for executions we write t1(1), t1(2), t2(3), t2(4)
for said interleaving.
3.3 Program order
Program order defines intra-thread execution order. That is, the execution order of operations within
the thread. You may think of the program order as the execution order of the operations of the thread,
when the thread is executed in isolation.
Definition 1.Given two actions a, bexecuted by the same thread t, we say aoccurs before baccording
to program order iff awould be performed before bwhen tis executed sequentially and in isolation
(i.e., without any other concurrent threads being part of the execution).
The program order relation is a total order among the operations of each thread.
Example 3.Consider again the concurrent program in example 1. The program has two threads. We
discuss the operations ordered by program order for each thread separately.
For thread one, denoted as t1, the program order relation includes the pair of actions ( t1(1), t1(2)).
Intuitively, this means that operation (1)must (appear) to occur before (2)within the thread. Note
3

that, since these two operations are not data dependent, the result of executing (1),(2) or(2),(1)
in a sequential execution, produces the same final value for aandx. Thus, the JIT compiler, JVM or
CPU can reorder these operations. However, as we will see later (cf. section 3.6), at the Java memory
model level only executions consistent with program order are valid. This is not a limitation, but
a huge advantage. This means that, as programmers, we do not need to worry about compiler or
CPU optimizations. We only need to consider valid executions at the memory model level, and the
JVM implementation takes care of only allowing optimizations that are consistent with the set of valid
executions for the program.
Analogously, for thread other , denoted as t2, program order includes the pair ( t2(3), t2(4)).
3.4 Happens-before order
Thehappens-before order establishes an order between actions of a concurrent program.
Definition 2.Given an execution e∈ E, and actions a, b∈e, we say that ahappens-before b, denoted
asa→b, iff
•Program order rule: Actions a, bare executed by the same thread, and aappears before bin
program order (cf. section 3.3).
•Monitor rule: Action ais an unlock() operation on a monitor,6andbis a subsequent lock()
operation on the same monitor.
•Volatile rule: Action ais a write access on a volatile variable, and bis a subsequent read access
on the same volatile variable.
•Default init rule: Action awrites the default value of a variable during object initialization and
bis the first action of any other thread. The default value for boolean variables is false, for
int/float /double is 0 and for non-primitive types (such as objects) is null.
•Final field init rule: Action awrites the initial value of a variable during object initialization
andbis the first action of any other thread.
•Thread start rule: Action ais a call to start() andbis the first action in the started thread.
•Thread termination rule: Action ais the last action executed by a thread and bis a call to
join() , by any other thread, to wait for the thread executing a.
•Transitive rule: Given an action c∈e, ifa→candc→b, then a→b.
The happens-before order is a partial order among the actions of an execution. Given a set of
happens-before pairs that are related by transitivity, such as {a1→a2, a2→a3, a3→a4, . . .}, we use
the syntax a1→a2→a3→a4→. . .for brevity and convenience.
3.5 Synchronization order
Due to non-determinism in the possible executions of a program, synchronization actions may syn-
chronize in different ways. The synchronization order relation establishes the legal ways in which
synchronization actions may occur in an execution. Synchronization order is important as it charac-
terizes the possible executions of a program (cf. section 3.8).
Definition 3.Given an execution e∈ E, asynchronization order is a total order between all synchro-
nization actions in esuch that:
6Here we use “monitor” as an abstract term, as the Java bytecode operations for synchronization use this term
(cf.https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-6.html ). However, the rule applies to the corre-
sponding operations in other synchronization objects such as locks, semaphores, barriers, etc.
4

•The synchronization order is consistent with mutual exclusion. This implies that lock() and
unlock() operations are correctly nested.
•The synchronization order is consistent with happens-before order (cf. section 3.4).
Each execution e∈ Ehas a synchronization order associated to it.
3.6 Well-formed executions
Now we are ready to define what a valid execution is according to the Java memory model. To this
end, we define well-formed executions.
Definition 4.An execution e∈ Eiswell-formed iff it is consistent with program order (cf. section 3.3),
happens-before order (cf. section 3.4) and synchronization order (cf. section 3.5).
Most importantly, given a concurrent Java program, the JVM only produces well-formed execu-
tions [2]. Thus, we can use the Java memory model to understand precisely the behavior of a Java
concurrent program.
3.7 Visibility
Establishing a happens-before order between read and write accesses ensures visibility. This is enforced
by the JVM. Programmers do not need to worry about the how the hardware ensures data consistency
in the different levels of the memory hierarchy. For programmers, it suffices to establish a happens-
before order between variables of interest at the programming language level.
Generally, given an execution e∈ Eand actions rx, wx∈ewhere rxis read access on a variable x
andwxa write access on x, ifwx→rxholds, then the effect of wxis visible to rx.
Note that showing wx→rxthat does guarantee that the value written by wxis the one that rx
reads. This is because the happens-before order can relate more than one write access to the read in
the same execution. For instance, consider the writes w′
x, w′′
w∈e, then we might have that wx→rx,
w′
x→rxandw′′
x→rxall hold in execution e. In this situation, the order of actions in the execution
determines the value read by rx.
Given an execution e∈ E, if we can show that wx→rxholds andfor any other write access w′
x∈e
it holds that w′
x→wx, then it is guaranteed that rxreads the value written by wx. This is because
we have showed that there cannot be any write access w′
xexecuted in between wxandrx.
3.8 A complete example
Here we discuss a complete example to illustrate the use of the Java memory model to predict the
value of program variables after the execution of the program. The example is purposely verbose. The
goal of the example is for you to see how to apply the definitions above. In practice, reasoning may
be more compact; (see, e.g., examples 6 and 7). However, remember that lack of precision can lead to
missing details, which may lead to incorrect conclusions.
Example 4.Consider the concurrent program in listing 2, which is a modification of the program
in example 1. Concretely, we have added a lock to ensure mutual exclusion on operations performed
by each thread. In this example, we use the Java memory model to show that the value of ( x,y)
after the execution of the program can only be (0,1) or (1,0)—i.e., the values (1,1) and (0,0) are not
possible.
To show that only the values ( x,y) after the execution of the program can only be (0,1) or (1,0), our
reasoning must encompass all well-formed executions (cf. section 3.6) of this program. In particular,
we must derive the pairs in the happens-before orders of all well-formed executions of the program.
First, let us identify the happens-before pairs originating from the program order rule. This pairs
must hold for all possible executions independently of synchronization order. For thread onewe have
5

Listing 2: Program using synchronization to remove unexpected behavior.
// Initial values
Lock l = new ReentrantLock ();
int x=0;y=0;
int a=0;b=0;
// Threads definition
Thread one = new Thread (() -> {
l. lock (); // (1)
a=1; // (2)
x=b; // (3)
l. unlock (); // (4)
}). start ();
Thread other = new Thread (() -> {
l. lock (); // (5)
b=1; // (6)
y=a; // (7)
l. unlock (); // (8)
}). start ();
t1(1)→t1(2), t1(2)→t1(3) and t1(3)→t1(4). For thread other we have t2(5)→t2(6), t2(6)→t2(7)
andt2(7)→t2(8). Thus, the happens-before order for each thread is defined as follows:
HBt1
po={t1(1)→t1(2), t1(2)→t1(3), t1(3)→t1(4), . . .},
HBt2
po={t2(5)→t2(6), t2(6)→t2(7), t2(7)→t2(8), . . .}.
We use . . .to denote that anything that can be derived by applying the transitive rule. For instance,
the set HBt1
poalso contains the pairs t1(1)→t1(3) or t1(1)→t1(4).
There exists also an implicit main thread, denoted as m, which performs the initialization of
the variables( x,y,a,band l) and starts the threads. Let us denote the initialization actions as
m(init(x)),m(init(y)),m(init(a)),m(init(b)), and m(init(l)). Let us denote the start thread oper-
ations as m(start (t1)),m(start (t2)). Then, the happens-before order for the main thread is defined
as:
HBm
po={m(init(l))→m(init(x)), m(init(x))→m(init(y)), m(init(y))→m(init(a)),
m(init(a))→m(init(b)), m(init(b))→m(start (t1)), m(start (t1))→m(start (t2)), . . .}.
In summary, the set of happens-before pairs from program order rules is defined as:
HB po=HBm
po∪HBt1
po∪HBt2
po.
The second step is to identify happens-before pairs involving initialization operations. Recall that,
by the thread start rule, the action executing start() happens-before the first action within the
started thread (cf. section 3.4). Then, for all program executions, the happens-before order includes
the following pairs:
HB init={m(start (t1))→t1(1), m(start (t2))→t2(5)}.
Third, we must define all possible synchronization orders. Synchronization orders characterize the
possible executions of a concurrent program. To this end, let us identify synchronization actions. The
program in listing 2 contains 6 synchronization actions: t1(1), t1(4), t2(5), t2(8), m(start (t1)) and
6

m(start (t2)), i.e., actions related to lock() /unlock() on lock land thread start actions. Let us use
Sto denote the set of synchronization orders for this program. There are 4 possible synchronization
orders for this program:
S={
(m(start (t1)), m(start (t2)), t1(1), t1(4), t2(5), t2(8)),
(m(start (t1)), t1(1), m(start (t2)), t1(4), t2(5), t2(8)),
(m(start (t1)), t1(1), t1(4), m(start (t2)), t2(5), t2(8)),
(m(start (t1)), m(start (t2)), t2(5), t2(8), t1(1), t1(4))
}.
Now we must argue that there are no other ordering of synchronization actions that would be consistent
with program order and mutual exclusion. There are only two nesting of synchronization operations
consistent with mutual exclusion either t1 acquires the lock before t2 or vice-versa. The first 3 cases
correspond to the situation when t1 acquires the lock before t2. In these cases, it must hold that
t1(4)→t2(5), and they must be consistent with program order, i.e., t1(1)→t1(4), t2(5)→t2(8) and
m(start (t1))→m(start (t2)). We have three cases for this situation depending on when m(start (t2))
occurs. Due to the thread start rule, this action must happen before t2(5). Thus, there are three
possibilities that are consistent with program order; either m(start (t2)) occurs: between m(start (t1))
andt1(1), or between t1(1) and t1(4), or between t1(4) and t2(5) The last synchronization order
inScorresponds to the case when t2 acquires the lock before t1. In this case, it must hold that
t2(8)→t1(1). Since, due to program order, we must have that m(start (t1))→m(start (t2)) and
m(start (t2))→t2(5), then there is only one possible order consistent with program order.
The next step is to derive the pairs of actions ordered by happens-before in the possible executions
of this program. Note that each synchronization order gives rise to a possible execution. However,
recall that HB poandHB inithold for all executions. This means that we only need to add the pairs
of actions in the synchronization orders that are not present in HB poorHB init. This only gives two
cases: when t1 acquires the lock first or when t2 acquires the lock first.7
Let us first consider the executions where t1 acquires the lock first. The only missing happens-
before pair—in the 3 synchronization orders for this case—that is not present in HB poandHB init
ist1(4)→t2(5). This pair is derived by applying the monitor rule (cf. section 3.4). Therefore, the
complete set of pairs ordered by happens-before in this execution, denoted by HB1is
HB1=HB init∪HB po∪ {t1(4)→t2(5)} ∪ {. . .}.
As before, the last {. . .}refers to the pairs obtained by transitivity from the complete set HB init∪
HB po∪ {t1(4)→t2(5)}.
For the case where t2 acquires the lock first, the reasoning is analogous. Thus, the only missing
happens-before pair is t2(8)→t1(1). Therefore,
HB1=HB init∪HB po∪ {t1(8)→t2(1)} ∪ {. . .}.
In summary, HB1andHB2capture the only two possible sets of happens-before orders for the
executions of this program. We will use these happens-before orders to show that the only possible
final values for xandyare (0,1) and (1,0).
We show that in HB1the final value of ( x,y) must be (0,1).
First we show that the value of ymust be 1 after execution. To this end, we must show that the
following holds
m(init(y))→m(init(a))→t1(2)→t2(7).
7This is a very common situation in programs with locks. When working on the exercises, you may omit listing
all synchronization orders as long as you can determine the distinct happens-before orders that capture all possible
executions.
7

This ensures that the last value written in yis 1 (cf. section 3.7). The pair m(init(y))→m(init(a))
follows trivially as it is in HB po. Then, we must show t1(2)→t2(7) and m(init(a))→t1(2) are in
HB1. The pair t1(2)→t2(7) follows by transitivity from the following pairs:
t1(2)→t1(3) in HB po
t1(3)→t1(4) in HB po
t1(4)→t2(5) from synchronization order in HB1
t2(5)→t2(6) in HB po
t2(6)→t2(7) in HB po.
The pair m(init(a))→t1(2) follows by transitivity from the following pairs:
m(init(y))→m(start (t1)) in HB po
m(start (t1))→t1(1) in HB init
t1(1)→t1(2) in HB po.
Thus, the value of yafter this execution is guaranteed to be 1.
Second we show that the value of xmust be 0 after execution. To this end, we must show that the
following holds
m(init(x))→m(init(b))→t1(3)→t2(6).
As before, this ensures that the last value written in xis 0 (cf. section 3.7). The pair m(init(x))→
m(init(b)) follows trivially as it is in HB po. Then, we must show that t1(3)→t2(6) and m(init(b)→
t1(3)) are in HB1. The pair t1(3)→t2(6) follows by transitivity,
t1(3)→t1(4) in HB po
t1(4)→t2(5) from synchronization order in HB1
t2(5)→t2(6) in HB po.
The pair m(init(b))→t1(3) follows by transitivity,
m(init(b))→m(start (t1)) in HB po
m(start (t1))→t1(1) in HB init
t1(1)→t1(2) in HB po
t2(2)→t2(3) in HB po.
Thus, the value of xafter this execution is guaranteed to be 0.
The same reasoning can be used to show that for HB2the final value of ( x,y) must be (1,0).
4 Correct concurrent Java programs
The Java memory model uses data race freedom as the notion of correctness for a concurrent Java
program. A concurrent program whose possible executions are data race free is known as correctly
synchronized. In what follows we precisely define this notion.
4.1 Conflicting actions
We start by defining the actions in an execution that can be potentially leading to a data race. These
actions are known as conflicting .
Definition 5.Given an execution e∈ E, we say that actions a, b∈eareconflicting iff they are accesses
on the same (non- volatile ) variable and at least one of them is a write access.
8

Example 5.Consider the program listing 2 from example 4. The actions t1(2) and t2(7)—present in all
the executions of the program—are an example of conflicting actions. This is because t1(1) performs
a write access on variable aandt2(7) performs a read access on the same variable.
We remark that variable accesses on volatile variables are never conflicting.
4.2 Data races
Now we are ready to introduce the definition of data race according to the Java memory model.
Definition 6.Given an execution e∈ E, there exist a data race between actions a, b∈eiffa, bare
conflicting and they are not ordered by happens-before.
Example 6.Consider again the program listing 2 from example 4. As mentioned in example 5, actions
t1(2) and t2(7) are conflicting. However, it holds that t1(2)→t2(7)∈HB1andt2(7)→t1(2)∈HB2
(cf. example 4). Therefore, this actions do not lead to a data race in any of the executions of the
program.
Example 7.Consider now the program listing 1 from example 1. The happens-before order for all
executions of the program only contains pairs of actions based on the program order rule, and the
synchronization actions from the thread start rule. That is,
HBm
po=m(init(x))→m(init(y))→m(init(a))→m(init(b)),
HBt1
po={t1(1)→t1(2)},
HBt2
po={t2(3)→t2(4)},and
HB init={m(start (t1))→t1(1), m(start (t2))→t2(5)}
such that HBfor all executions of this program is the transitive closure of HBm
po∪HBt1
po∪HBt2
po∪HB init.
However, due to the lack of synchronization actions between threads t1 and t2, it trivially follows that
neither t1(2)→t2(7) nor t2(7)→t1(2) are in HB. Consequently, this program contains (at least) a
data race. In other words, the program is not data race free.
4.3 Correctly synchronized programs
Finally, we are ready to precisely define correctness for Java concurrent programs as stated in the Java
memory model.
Definition 7.A program is correctly synchronized iff none of its executions contains data races.
Example 8.Given the reasoning in example 7, we can conclude that the program in listing 1 is not
correctly synchronized.
Example 9.Consider now the program listing 2 from example 4. We show here that it is correctly
synchronized, i.e., no execution contains data races.
First, we identify all conflicting actions in the executions of the program. We group them by
variable:
•For variable awe have:
–(m(init(a)), t1(2))
–(m(init(a)), t2(7))
–(t1(2), t2(7))
•For variable bwe have:
–(m(init(b)), t1(3))
–(m(init(b)), t2(6))
9

–(t1(3), t2(6))
•For variable xwe have only ( m(init(x)), t1(3))
•For variable ywe have only ( m(init(y)), t2(7))
Recall that this program has two possible sets of happens-before orders for all actions HB1,HB2,
which correspond to whether the lock is first acquired by t1 ort2, respectively. Note that in both
happens-before orders it holds that initialization operations happen-before the operations within each
thread. That is, by the program order and the thread start rules, HB1andHB2for any action a
within t1 and t2 we have
m(init(x))→m(init(y))→m(init(a))→m(init(b))→a
This proves that there cannot be data races in conflicting pairs of actions involving an initialization
operation. Thus, we are left to show that either t1(2)→t2(7) or t2(7)→t1(2) is in HB1,HB2and
similarly for ( t1(3), t2(6)). The reason why we must consider both directions is that the actions must
be ordered by happens-before in all possible executions. Since depending on what thread acquires the
lock first, we might have a different order, it is necessary to consider both directions. In example 4 we
have already shown that t1(2)→t2(7) is in HB1. Using the pairs of actions from program order and
using the happens-before pair t2(8)→t1(1) from the monitor rule and the synchronization order for
HB2, we have t2(7)→t2(8)→t1(1)→t1(2) is in HB2. Analogous reasoning can be used to show
thatt1(3)→t2(6)∈HB1andt2(6)→t1(3)∈HB2. Thus, we have shown that all conflicting actions
are ordered by happens-before in all program executions. Consequently, we can conclude no execution
leads to data races, which implies that the program is correctly synchronized.
4.3.1 A remark on sequential consistency
The Java memory model ensures that all executions of correctly synchronized programs are sequentially
consistent (cf. section 2). This is very useful for programmers, as it ensures that runtime, compiler or
CPU optimizations cannot produce unexpected executions. In other words, programmers can ignore
these optimizations when writing concurrent programs, and simply focus on the rules of the Java
memory model.
5 A few more examples
In this section, we show how to use happens-before order rules and reasoning in situations distinct
from the ones in previous examples. Nevertheless, we remark that the complete example in section 3.8
illustrates how to use all the core elements of the Java memory model.
5.1 Example with volatile variables
Example 10.Consider a modification of the program in listing 1 from example 1 where we declare
variables a,basvolatile . In lecture 2, we discussed that this modification does not allow executions
where the final value of ( x,y) is (0,0). We can use the Java memory model to argue why this is the
case. In particular, we show that the modified program is correctly synchronized. As a consequence
of this, only sequentially consistent executions are valid, which—as mentioned in section 2—does not
allow executions producing (0,0).
To show that the modified program is correctly synchronized, we must show that no execution
contains data races (cf. section 4.3).
Before we argue about the happens-before order sets that capture all execution of this program,
let us identify the conflicting actions in the program. Recall that, by definition, actions involving
read/write accesses on volatile variables are not conflicting (cf. section 4.1). Thus, the only pairs of
conflicting actions in the program are: m(init(x), t1(2)) and m(init(y), t2(4)).
10

The happens-before order sets containing actions pairs from the program order and thread start
rule ( HB poandHB init) are defined as follows:
HBm
po=m(init(x))→m(init(y))→m(init(a))→m(init(b))→m(start (t1))→m(start (t2))
HBt1
po=t1(1)→t1(2)
HBt2
po=t2(3)→t2(4)
HB init={m(start (t1))→t1(1), m(start (t2))→t2(3)}
As before, we use HBto denote the transitive closure of HBm
po∪HBt1
po∪HBt2
po∪HB init. Typically, at
this point, we should identify all possible synchronization orders for this program. Given that actions
involving read/write accesses on volatile variables are synchronization actions, we must consider all
possible total orders of the actions m(start (t1)),m(start (t2)),t1(1), t1(2), t2(3) and t2(4). However,
recall that all synchronization orders must be consistent with HB poandHB init. Therefore, for all
executions, the action pairs in HBmust hold.
We show that m(init(x)→t1(2)) and m(init(y)→t2(4)) hold in HB.
m(init(x))→m(start (t1)) in HB po
m(start (t1))→t1(1) in HB init
t1(1)→t1(2) in HB po
and
m(init(y))→m(start (t2)) in HB po
m(start (t2))→t2(3) in HB init
t2(3)→t2(4) in HB po.
Thus, we have shown that the conflicting actions in the program are ordered by happens-before
for all executions. As a consequence, the program is data race free, which, in turn, implies that the
program is correctly synchronized.
Since the program is correctly synchronized, all executions are sequentially consistent. Thus, no
execution ends with the value (0,0) for variables ( x,y); as producing these values requires violating
program order.
5.2 Example with conditional statements
The presence of conditional statements—such as iforwhile —impacts the set of action pairs ordered
by happens-before. This impact is not mechanically derived from the core elements of the Java memory
models discussed in section 3. When determining the set of executions in a program with conditional
statements, we must analyze whether the predicates in the conditional statements evaluate to true or
not. It is possible that there will be different sets of happens-before orders depending on the evaluation
of the predicate. In what follows, we describe an example illustrating some of these subtleties.
Example 11.Consider the program in listing 3. We will show that, depending on whether the boolean
variable cis initialized to false ortrue, the set of executions will change. Consequently, this will
result in different happens-before order sets.
Consider version 1 of the program in listing 3. That is, the case where variable cis initialized to
false . We have the following happens-before order sets from program order and thread start rules:
HBm
po=m(init(c))→m(init(x))→m(init(y))→m(start (t1))→m(start (t2))
HB init={m(start (t1))→t1(1), m(start (t2))→t2(3)}
Note that there are no sets for HBt1
poandHBt2
po. This is not an error.
11

Listing 3: Program with a conditional statement.
// Initial values
boolean c= false ; // version 1
// boolean c= true ; // version 2
int x=0;y=0;
// Threads definition
Thread one = new Thread (() -> {
if(c) { // (1)
x=1; // (2)
}
}). start ();
Thread other = new Thread (() -> {
y=x; // (3)
}). start ();
The set HBt2
pois empty simply because the t2 only contains one operation.
The explanation why HBt1
pois empty is more subtle; as it is a consequence of the conditional
statement. First, note that HBm
poandHB inithold for all executions. This is because all synchro-
nization orders must consistent with the pairs of actions in those sets. Due to this, we can show that
m(init(c))→t1(1):
m(init(c))→m(start (t1)) in HB po
m(start (t1))→t1(1) in HB init.
Since there are no other write access on variable c. This implies that, for all executions, t1(1) will read
the value false . As a consequence, action t1(2) is not executed in any valid execution of the program.
Since t1(2) is not present in any execution of the program, then there cannot be happens-before pairs
including it. This results in t1 effectively only executing one operation in all executions of the program.
In summary, both, HBt1
poandHBt2
po, are empty, as any execution in version 1 only includes one
operation for these threads.
Consider now version 2 of the program in listing 3. That is, the case where variable cis initialized
totrue. We can use the same reasoning as above to show that t1(1) reads the value true for variable
cin all executions. Therefore, action t1(2) is executed in all executions, which implies that HBt1
po=
t1(1)→t1(2) holds for all executions.
References
[1] Leslie Lamport. “How to Make a Multiprocessor Computer That Correctly Executes Multiprocess
Programs”. In: IEEE Trans. Computers 28.9 (1979), pp. 690–691.
[2] Jeremy Manson, William W. Pugh, and Sarita V. Adve. “The Java memory model”. In: Proceed-
ings of the 32nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages,
POPL’05 . ACM, 2005, pp. 378–391.
12

